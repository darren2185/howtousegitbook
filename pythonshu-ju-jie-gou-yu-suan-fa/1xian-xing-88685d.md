# 线性表

---

集合E上的一个线性表就是E中一组有穷个元素排成的序列L=\(e0, e1,...., en-1\)，其中ei属于E且n ≥ 0。在一个表里可以包含0个或多个元素，序列中的每个元素在表里有一个确定的位置，称之为下表，Python一般从0开始。一个表中包含的元素的个数称为长度，显然，空表为0。在一个费控的线性表里，存在着唯一的首元素和一个尾元素，除首元素外，表中每个元素都有一个前驱元素，与之相对的除尾元素外，表中每个元素都有一个后驱元素。

#### 线性表抽象数据类型

```ADT
ADT List:                           # 一个线性表抽象数据类型
    List(self)                      # 表构造操作，创建一个新表
    is_empty(self)                  # 判断self是否为空表
    length(self)                    # 获得self的长度
    prepend(self, element)          # 将元素element加入表中作为第一个元素
    append(self, element)           # 将元素element加入表中作为最后一个元素
    insert(self, element, index)    # 将元素element加入表中作为第index个元素，其他元素的顺序不变
    del_first(self)                 # 删除表中的首元素
    del_last(self)                  # 删除表中的尾元素
    del(self, index)                # 删除表中的第i个元素
    search(self, element)           # 查找元素element在表中的出现位置，不出现则返回 -1
    forall(self,op)                 # 对表中的每个元素执行操作Op
```

### 顺序表

表中元素顺序存放在一片足够大的连续存储区里，首元素存入存储区的开始位置，其余元素依次顺序存放。元素之间的逻辑顺序关系通过元素在存储区里的物理位置表示。

表的顺序实现（书序表）的总结：

优点：O\(1\)时间的（随机、直接的）按位置访问元素；元素在表里存储紧凑，除表元素存储区之外只需要O\(1\)空间存放少量辅助信息。

缺点：需要连续的存储区存放表中的元素，如果表很大，就需要很大片的连续内存空间。一旦确定了存储块的大小，可容纳单元个数并不随着插入/删除操作的进行而变化。如果很大的存储区里只保存了少量数据，就会有大量空闲单元，造成表内的存储浪费。在执行加入或删除操作时，通常需要移动许多元素，效率低。建表时需要考虑存储区大小，而实际需求很难事先估计。

##### 总结

采用顺序表结构实现线性表：

* O\(1\)时间的定位元素访问，很多简单操作的效率也比较高
* 由于元素在顺序表的存储区里连续排列，加入/删除操作有可能移动很多元素，操作代价高
* 只有特殊的尾端插入/删除操作具有O\(1\)时间复杂度，插入操作复杂度还收到元素存储区固定大小的闲置。通过适当的存储区扩充策略，一系列尾端插入可以达到O\(1\)的平均复杂度。

顺序表的优点和缺点都在于其元素存储的集中方式和连续性。从缺点看，这样的表结构不够灵活，不容易调整和变化。

#### 链表

1， 能够找到表中的首元素，2，从表里的任一元素出发，可以找到它之后的下一个元素，3，并不一定需要连续存储元素，基于链接结构，用链接关系显示表示元素之间的顺序关联（连接表）





